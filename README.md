# QUEUE MANAGEMENT APPLICATION

![app interface](https://i.imgur.com/IEqTrct.png)

## Objectives
The primary objective of this project is to create a queue management system that manages a list of clients in a series of servers and puts the client in the queue with the least waiting time. The secondary objectives are to create a user interface to input the required data for the project simulation, a simulation manager, a scheduler, a text file to keep logs of events every second, synchronization of threads, stop simulation, kill threads, generate a client list based on inputs, and update the user interface with the results of the program.

## Problem Analysis, Scenarios, Use Cases
This program takes a set of inputs from the keyboard in several text fields provided by the user interface. It generates a list of clients with random attributes based on the values given in the GUI. The Scheduler sorts the list based on each client's generated arrival time, ensuring that when the client arrives, they are put in an appropriate queue with the shortest waiting time.

Stopping the simulation and all the threads created by the program can be difficult. To overcome this, an attribute was created called "notExit," which functions as a flag. It was eventually the best way to solve the problem. The attribute "notExit" is controlled in the simulation manager by the "exitApp" function, which stops the threads created by the program.

This kind of application is useful in day-to-day scenarios where resources need to be managed. In this case, the resource is time. Each task needs to be completed as quickly as possible, so the best waiting time is calculated, and the task is sent to the shortest queue by time.

Step-by-step functionality includes taking a list of clients and sorting it by their arrival time. The program iterates through the client list, dispatches them to the scheduler when the current time equals the client's arrival time, and computes the minimum waiting times for each server. Then it adds the current task to that one queue. This is repeated until the simulation current time reaches the time limit.

## Design
Package:
![Package diagram](https://i.imgur.com/xsVvu2t.png)
Class:
![Class diagram](https://i.imgur.com/6PqdV0e.png)

## Implementation
The "run" method in the simulation manager is the most important method because the clients are iterated and dispatched there. The output functionalities of the program are present in this method as well, and the log.txt file gets updated, along with the text area of the interface. The task generator in the simulation manager generates tasks with the required attributes randomized between max arrival, min arrival, and processing time. The list gets sorted using the Collections.sort method, and a rule is created in the class Sortbyarrival.

The controller manages the user interface and handles the events generated by the user interface. When the simulation button is clicked, the simulation manager is called with the required input parameters, and the simulation starts.

## Results
The queue management application was successfully implemented according to the design and objectives defined at the beginning of the project. The program has been tested using different input values, and it has performed well, providing the expected output.
The user interface provides an easy way to input the required data.

![input data](https://i.imgur.com/YjZXqVU.png)

The log file will contain the following set of data:
Current time: 1
Waiting list:[6 2 2][4 5 3][3 7 2][7 7 2][2 10 4][5 11 2][1 13 2]
Queue1 
Queue2 

Current time: 2
Waiting list:[4 5 3][3 7 2][7 7 2][2 10 4][5 11 2][1 13 2]
Queue1 [6 2 2] 
Queue2 

Current time: 3
Waiting list:[4 5 3][3 7 2][7 7 2][2 10 4][5 11 2][1 13 2]
Queue1 [6 2 1] 
Queue2 

Current time: 4
Waiting list:[4 5 3][3 7 2][7 7 2][2 10 4][5 11 2][1 13 2]
Queue1 
Queue2 

Current time: 5
Waiting list:[3 7 2][7 7 2][2 10 4][5 11 2][1 13 2]
Queue1 
Queue2 [4 5 3] 

Current time: 6
Waiting list:[3 7 2][7 7 2][2 10 4][5 11 2][1 13 2]
Queue1 
Queue2 [4 5 2] 

and so on...

One of the trickier parts of the project was stopping the simulation and all the threads created by the program. However, a flag attribute named "notExit" was implemented to solve this problem.

The program can be useful in day-to-day scenarios where it is required to manage resources, especially time. Each task needs to be completed as fast as possible, so the best waiting time is calculated and based on it. The
